#!/usr/bin/env python3
"""
Organisateur de Photos - Version 2.0
Application moderne et simple pour trier automatiquement vos photos par date
Interface pens√©e pour les utilisateurs non-techniques
"""

import tkinter as tk
from tkinter import filedialog, messagebox, ttk
import os
import shutil
from datetime import datetime
from pathlib import Path
import threading
import json
import hashlib
from PIL import Image
from PIL.ExifTags import TAGS

# Dictionnaire des noms de mois en fran√ßais
MOIS_FRANCAIS = {
    1: "Janvier", 2: "F√©vrier", 3: "Mars", 4: "Avril",
    5: "Mai", 6: "Juin", 7: "Juillet", 8: "Ao√ªt",
    9: "Septembre", 10: "Octobre", 11: "Novembre", 12: "D√©cembre"
}

class PhotoOrganizer:
    def __init__(self, root):
        self.root = root
        self.root.title("üì∏ Organisateur de Photos - Simple et Efficace")
        self.root.geometry("700x800")
        self.root.resizable(True, True)
        
        # Fichier de configuration
        self.config_file = "photo_organizer_config.json"
        
        self.source_folder = tk.StringVar()
        self.dest_folder = tk.StringVar()
        
        # Options de traitement
        self.sort_by_date = tk.BooleanVar(value=True)
        self.copy_mode = tk.BooleanVar(value=True)
        
        # Charger la configuration sauvegard√©e
        self.load_config()
        
        # Configuration du style moderne
        self.setup_style()
        self.setup_ui()
        
        # Sauvegarder la config √† la fermeture
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)
    
    def setup_style(self):
        """Configure un style moderne pour l'interface"""
        style = ttk.Style()
        
        # Couleurs modernes
        style.configure('Title.TLabel', font=('Segoe UI', 18, 'bold'), foreground='#2c3e50')
        style.configure('Heading.TLabel', font=('Segoe UI', 12, 'bold'), foreground='#34495e')
        style.configure('Info.TLabel', font=('Segoe UI', 10), foreground='#7f8c8d')
        style.configure('Modern.TButton', font=('Segoe UI', 10, 'bold'), padding=10)
        style.configure('Action.TButton', font=('Segoe UI', 14, 'bold'), padding=15)
        
        # Style pour les frames
        style.configure('Card.TFrame', relief='solid', borderwidth=1)
        
    def load_config(self):
        """Charge la configuration sauvegard√©e"""
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, 'r', encoding='utf-8') as f:
                    config = json.load(f)
                    self.source_folder.set(config.get('source_folder', ''))
                    self.dest_folder.set(config.get('dest_folder', ''))
                    self.sort_by_date.set(config.get('sort_by_date', True))
                    self.copy_mode.set(config.get('copy_mode', True))
        except Exception as e:
            print(f"Erreur lors du chargement de la configuration: {e}")
    
    def save_config(self):
        """Sauvegarde la configuration actuelle"""
        try:
            config = {
                'source_folder': self.source_folder.get(),
                'dest_folder': self.dest_folder.get(),
                'sort_by_date': self.sort_by_date.get(),
                'copy_mode': self.copy_mode.get()
            }
            with open(self.config_file, 'w', encoding='utf-8') as f:
                json.dump(config, f, indent=2, ensure_ascii=False)
        except Exception as e:
            print(f"Erreur lors de la sauvegarde de la configuration: {e}")
    
    def on_closing(self):
        """Appel√© lors de la fermeture de l'application"""
        self.save_config()
        self.root.destroy()
        
    def setup_ui(self):
        # Conteneur principal avec padding g√©n√©reux
        main_container = ttk.Frame(self.root, padding="20")
        main_container.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Configuration du redimensionnement
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        main_container.columnconfigure(0, weight=1)
        # Pas de zone extensible, taille fixe optimis√©e
        
        # === TITRE PRINCIPAL ===
        title_frame = ttk.Frame(main_container)
        title_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 20))
        title_frame.columnconfigure(0, weight=1)
        
        ttk.Label(title_frame, text="üì∏ Organisateur de Photos", 
                 style='Title.TLabel').grid(row=0, column=0)
        ttk.Label(title_frame, text="Triez automatiquement vos photos par date en quelques clics", 
                 style='Info.TLabel').grid(row=1, column=0, pady=(5, 0))
        
        # === SECTION DOSSIERS ===
        folders_frame = ttk.LabelFrame(main_container, text=" üìÅ S√©lection des dossiers ", 
                                      padding="15", style='Card.TFrame')
        folders_frame.grid(row=1, column=0, sticky=(tk.W, tk.E), pady=(0, 15))
        folders_frame.columnconfigure(1, weight=1)
        
        # Dossier source
        ttk.Label(folders_frame, text="üîç Dossier contenant vos photos:", 
                 style='Heading.TLabel').grid(row=0, column=0, sticky=tk.W, pady=(0, 5))
        ttk.Label(folders_frame, text="(Toutes les photos seront trouv√©es automatiquement, m√™me dans les sous-dossiers)", 
                 style='Info.TLabel').grid(row=1, column=0, columnspan=3, sticky=tk.W, pady=(0, 10))
        
        source_entry = ttk.Entry(folders_frame, textvariable=self.source_folder, font=('Segoe UI', 10))
        source_entry.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E), padx=(0, 10))
        ttk.Button(folders_frame, text="üìÇ Choisir", command=self.select_source_folder, 
                  style='Modern.TButton').grid(row=2, column=2)
        
        # S√©parateur visuel
        ttk.Separator(folders_frame, orient='horizontal').grid(row=3, column=0, columnspan=3, 
                                                              sticky=(tk.W, tk.E), pady=15)
        
        # Dossier destination
        ttk.Label(folders_frame, text="üíæ Dossier o√π sauvegarder les photos tri√©es:", 
                 style='Heading.TLabel').grid(row=4, column=0, sticky=tk.W, pady=(0, 5))
        ttk.Label(folders_frame, text="(Les photos seront organis√©es par ann√©e puis par mois)", 
                 style='Info.TLabel').grid(row=5, column=0, columnspan=3, sticky=tk.W, pady=(0, 10))
        
        dest_entry = ttk.Entry(folders_frame, textvariable=self.dest_folder, font=('Segoe UI', 10))
        dest_entry.grid(row=6, column=0, columnspan=2, sticky=(tk.W, tk.E), padx=(0, 10))
        ttk.Button(folders_frame, text="üìÇ Choisir", command=self.select_dest_folder, 
                  style='Modern.TButton').grid(row=6, column=2)
        
        # === SECTION OPTIONS ===
        options_frame = ttk.LabelFrame(main_container, text=" ‚öôÔ∏è Options de traitement ", 
                                      padding="15", style='Card.TFrame')
        options_frame.grid(row=2, column=0, sticky=(tk.W, tk.E), pady=(0, 15))
        
        # Option tri par date avec explication claire
        sort_frame = ttk.Frame(options_frame)
        sort_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 10))
        
        self.sort_checkbox = ttk.Checkbutton(sort_frame, text="üìÖ Trier les photos par date", 
                                           variable=self.sort_by_date, 
                                           command=self.on_sort_option_changed)
        self.sort_checkbox.grid(row=0, column=0, sticky=tk.W)
        
        self.sort_info = ttk.Label(sort_frame, text="", style='Info.TLabel', wraplength=600)
        self.sort_info.grid(row=1, column=0, sticky=tk.W, padx=(25, 0), pady=(5, 0))
        
        # Option copie/d√©placement avec explication claire  
        copy_frame = ttk.Frame(options_frame)
        copy_frame.grid(row=1, column=0, sticky=(tk.W, tk.E))
        
        self.copy_checkbox = ttk.Checkbutton(copy_frame, text="üìã Conserver les photos originales", 
                                           variable=self.copy_mode,
                                           command=self.on_copy_option_changed)
        self.copy_checkbox.grid(row=0, column=0, sticky=tk.W)
        
        self.copy_info = ttk.Label(copy_frame, text="", style='Info.TLabel', wraplength=600)
        self.copy_info.grid(row=1, column=0, sticky=tk.W, padx=(25, 0), pady=(5, 0))
        
        # Mise √† jour initiale des textes d'aide
        self.on_sort_option_changed()
        self.on_copy_option_changed()
        
        # === BOUTON PRINCIPAL ===
        action_frame = ttk.Frame(main_container)
        action_frame.grid(row=3, column=0, pady=15, sticky=tk.W+tk.E)
        action_frame.columnconfigure(0, weight=1)
        
        self.start_button = ttk.Button(action_frame, text="üöÄ ORGANISER MES PHOTOS", 
                                      command=self.start_organizing, style='Action.TButton')
        self.start_button.grid(row=0, column=0)
        
        # === ZONE DE PROGRESSION ===
        progress_frame = ttk.Frame(main_container)
        progress_frame.grid(row=4, column=0, sticky=(tk.W, tk.E), pady=(15, 20))
        progress_frame.columnconfigure(0, weight=1)
        
        # Barre de progression
        self.progress = ttk.Progressbar(progress_frame, mode='determinate', style='TProgressbar')
        self.progress.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 10))
        
        # Label de statut simple
        self.status_label = ttk.Label(progress_frame, text="‚ú® Pr√™t √† organiser vos photos !", 
                                     style='Info.TLabel', anchor='center')
        self.status_label.grid(row=1, column=0, sticky=(tk.W, tk.E))
        
    def on_sort_option_changed(self):
        """Met √† jour le texte d'aide pour l'option de tri"""
        if self.sort_by_date.get():
            text = "‚úì Cr√©era des dossiers par ann√©e (ex: 2023, 2024) puis par mois (ex: Janvier, F√©vrier)"
        else:
            text = "‚óã Toutes les photos seront plac√©es directement dans le dossier de destination"
        self.sort_info.config(text=text)
        
    def on_copy_option_changed(self):
        """Met √† jour le texte d'aide pour l'option de copie"""
        if self.copy_mode.get():
            text = "‚úì Les photos originales restent dans leur dossier actuel (recommand√© pour la s√©curit√©)"
        else:
            text = "‚óã Les photos seront d√©plac√©es (supprim√©es de leur emplacement actuel)"
        self.copy_info.config(text=text)
        
    def select_source_folder(self):
        folder = filedialog.askdirectory(title="Choisir le dossier contenant vos photos")
        if folder:
            self.source_folder.set(folder)
            self.save_config()  # Sauvegarde imm√©diate
            self.update_status(f"üìÅ Dossier source s√©lectionn√©")
            
    def select_dest_folder(self):
        folder = filedialog.askdirectory(title="Choisir le dossier de destination")
        if folder:
            self.dest_folder.set(folder)
            self.save_config()  # Sauvegarde imm√©diate
            self.update_status(f"üíæ Dossier de destination s√©lectionn√©")
    
    def update_status(self, message):
        """Met √† jour le message de statut"""
        self.status_label.config(text=message)
        self.root.update_idletasks()
    
    def get_photo_date(self, filepath):
        """Extrait la date de prise de vue depuis les m√©tadonn√©es EXIF"""
        try:
            with Image.open(filepath) as image:
                exifdata = image.getexif()
                
                # Recherche de la date de prise de vue
                for tag_id in exifdata:
                    tag = TAGS.get(tag_id, tag_id)
                    data = exifdata.get(tag_id)
                    
                    if tag in ["DateTime", "DateTimeOriginal", "DateTimeDigitized"]:
                        try:
                            return datetime.strptime(data, "%Y:%m:%d %H:%M:%S")
                        except:
                            continue
        except Exception as e:
            pass  # Erreurs EXIF silencieuses pour les utilisateurs non-techniques
        
        # Si pas de donn√©es EXIF, utiliser la date de modification du fichier
        try:
            return datetime.fromtimestamp(os.path.getmtime(filepath))
        except:
            return datetime.now()
    
    def get_year_month_path(self, date):
        """G√©n√®re le chemin des dossiers au format 'Ann√©e/Mois'"""
        try:
            month_name = MOIS_FRANCAIS[date.month]
            year = date.strftime("%Y")
            return os.path.join(year, month_name)
        except:
            return os.path.join(str(datetime.now().year), "Inconnu")
    
    def files_are_identical(self, file1_path, file2_path):
        """V√©rifie si deux fichiers sont identiques (m√™me taille et m√™me contenu)"""
        try:
            # V√©rification rapide par la taille
            if os.path.getsize(file1_path) != os.path.getsize(file2_path):
                return False
            
            # Si m√™me taille, v√©rification par hash (plus fiable)
            def get_file_hash(filepath):
                hash_md5 = hashlib.md5()
                with open(filepath, "rb") as f:
                    # Lire par chunks pour les gros fichiers
                    for chunk in iter(lambda: f.read(4096), b""):
                        hash_md5.update(chunk)
                return hash_md5.hexdigest()
            
            return get_file_hash(file1_path) == get_file_hash(file2_path)
        except:
            return False
    
    def organize_photos(self):
        """Organise les photos par date"""
        source = self.source_folder.get()
        destination = self.dest_folder.get()
        
        if not source or not destination:
            messagebox.showerror("‚ùå Erreur", "Veuillez s√©lectionner les dossiers source et destination")
            return
        
        if not os.path.exists(source):
            messagebox.showerror("‚ùå Erreur", "Le dossier source n'existe pas")
            return
        
        # D√©sactiver le bouton pendant le traitement
        self.start_button.config(state='disabled', text="‚è≥ Traitement en cours...")
        
        # Extensions de fichiers photos support√©es
        photo_extensions = {'.jpg', '.jpeg', '.png', '.tiff', '.tif', '.bmp', '.gif', '.raw', '.cr2', '.nef', '.arw', '.heic', '.webp'}
        
        # Collecte de tous les fichiers photos
        self.update_status("üîç Recherche des photos...")
        photo_files = []
        for root, dirs, files in os.walk(source):
            for file in files:
                if Path(file).suffix.lower() in photo_extensions:
                    photo_files.append(os.path.join(root, file))
        
        total_files = len(photo_files)
        if total_files == 0:
            messagebox.showinfo("‚ÑπÔ∏è Information", "Aucune photo trouv√©e dans le dossier source")
            self.start_button.config(state='normal', text="üöÄ ORGANISER MES PHOTOS")
            return
        
        # Mise √† jour du statut
        self.update_status(f"üìä {total_files} photos trouv√©es - Traitement en cours...")
        self.progress['maximum'] = total_files
        
        processed = 0
        errors = 0
        skipped_duplicates = 0
        
        for i, photo_path in enumerate(photo_files):
            try:
                filename = os.path.basename(photo_path)
                
                # D√©terminer le dossier de destination selon l'option de tri
                if self.sort_by_date.get():
                    # Obtenir la date de la photo et cr√©er le dossier par date
                    photo_date = self.get_photo_date(photo_path)
                    year_month_path = self.get_year_month_path(photo_date)
                    dest_folder_path = os.path.join(destination, year_month_path)
                    dest_info = f"{filename} ‚Üí {year_month_path.replace(os.sep, '/')}"
                else:
                    # Pas de tri, directement dans le dossier de destination
                    dest_folder_path = destination
                    dest_info = f"{filename} ‚Üí dossier destination"
                
                # Cr√©er le dossier s'il n'existe pas
                os.makedirs(dest_folder_path, exist_ok=True)
                
                # Nom du fichier de destination
                dest_file_path = os.path.join(dest_folder_path, filename)
                
                # V√©rifier si le fichier existe d√©j√†
                if os.path.exists(dest_file_path):
                    # V√©rifier si c'est exactement le m√™me fichier
                    if self.files_are_identical(photo_path, dest_file_path):
                        # Fichier identique d√©j√† pr√©sent, on l'ignore
                        skipped_duplicates += 1
                        if (processed + skipped_duplicates) % 10 == 0:
                            self.update_status(f"üì∏ Traitement... {processed + skipped_duplicates}/{total_files} photos")
                        continue
                    else:
                        # Fichier diff√©rent avec m√™me nom, on ajoute un num√©ro
                        counter = 1
                        original_dest_path = dest_file_path
                        while os.path.exists(dest_file_path):
                            name, ext = os.path.splitext(original_dest_path)
                            dest_file_path = f"{name}_{counter}{ext}"
                            counter += 1
                
                # Copier ou d√©placer selon l'option choisie
                if self.copy_mode.get():
                    shutil.copy2(photo_path, dest_file_path)
                    action = "üìã"
                else:
                    shutil.move(photo_path, dest_file_path)
                    action = "üì¶"
                
                # Mise √† jour du statut occasionnelle
                if (processed + skipped_duplicates) % 10 == 0:  # Toutes les 10 photos
                    self.update_status(f"üì∏ Traitement... {processed + skipped_duplicates}/{total_files} photos")
                processed += 1
                
            except Exception as e:
                errors += 1
                # Erreurs silencieuses pour simplicit√©
            
            # Mise √† jour de la barre de progression
            self.progress['value'] = i + 1
            self.root.update_idletasks()
        
        # Statut final
        if errors == 0 and skipped_duplicates == 0:
            self.update_status(f"üéâ Termin√© ! {processed} photos organis√©es avec succ√®s")
        elif skipped_duplicates > 0 and errors == 0:
            self.update_status(f"‚úÖ Termin√© ! {processed} nouvelles photos, {skipped_duplicates} doublons ignor√©s")
        else:
            self.update_status(f"‚úÖ Termin√© ! {processed} photos trait√©es, {skipped_duplicates} doublons ignor√©s, {errors} erreurs")
        
        # R√©activer le bouton
        self.start_button.config(state='normal', text="üöÄ ORGANISER MES PHOTOS")
        
        # Notification finale
        message_parts = []
        if processed > 0:
            message_parts.append(f"‚úÖ {processed} photos organis√©es")
        if skipped_duplicates > 0:
            message_parts.append(f"üîÑ {skipped_duplicates} doublons ignor√©s")
        if errors > 0:
            message_parts.append(f"‚ö†Ô∏è {errors} erreurs")
            
        if errors == 0:
            messagebox.showinfo("üéâ Succ√®s", f"Organisation termin√©e !\n\n{chr(10).join(message_parts)}\n\nüìÅ Vos photos sont dans: {destination}")
        else:
            messagebox.showwarning("‚ö†Ô∏è Termin√© avec avertissements", f"Organisation termin√©e !\n\n{chr(10).join(message_parts)}")
    
    def start_organizing(self):
        """Lance l'organisation dans un thread s√©par√©"""
        # Sauvegarder la config avant de commencer
        self.save_config()
        threading.Thread(target=self.organize_photos, daemon=True).start()

def main():
    root = tk.Tk()
    app = PhotoOrganizer(root)
    root.mainloop()

if __name__ == "__main__":
    main()